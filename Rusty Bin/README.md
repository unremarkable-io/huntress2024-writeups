# Rusty Bin

## Dynamic (CTF) solve

Binary written is Rust, not trivial to RE. Setup a bunch of breakpoints places to roughly determine what prints what.

Turns out `sub_7FF6629E1CB0()` is the decrypt function, last (3rd) parameter being the id of the string to decrypt.

- 800 - `the password`
- 1335 - `What is 'the password'`
- 1336 - `Wrong Password`
- 1337 - `Correct Password! Here's a clue!`

It would print hints like `cafb` (id 2), `c80b` (id 3) or `1964` (id 5).

Turns out string ids 0 (zero) through 9 concatenated together are the flag (in pieces).

```
0 flag
1 {e65
2 cafb
3 c80b
4 d66a
5 1964
6 b2e9
7 debe
8 f3ca
9 e}

flag{e65cafbc80bd66a1964b2e9debef3cae}
```

During the CTF I'd just set up a breakpoint before call to `sub_7FF6629E1CB0`, change RDX to an ID I wanted and extracted
the flag manually.

## Static solve

The entire lookup table is "hidden" in the PE resources:

```shell
% r.ef rusty_bin | r.perc 'RCDATA/100/1033' | r.snip 248:828 1076:1656 [| r.pop first [| r.xor var:first ]]
```

Here are the file offsets of both of those pieces

```
0x478E08
9D4A41EF46879C14AF2C4115F8575D7A9245EC846E4E14D4F6278FD5208D27CC55B50C5936C414E36B28CA06D24FA4AE71419B538FC43E2E5171A854E3C0B4B80FD6292676EBB46B541F5F89A6EBED88AF1B823562A5B9EB4934D9512426C42EF9476B31EDA0CCA96D9854A859384407A28EFC9329E6140BC299F60E23C0ED4D8592A91CB2BC6FC6A3200D01EB282C20FE1E124FA292C7A1ECB53530A96111EA550C559ADD8902DCAF498F67A830183EF6569E3EA7466D653C1FD9F62C2611B2DCC5EE4AA3985753255F67C66351A477B68E0D5A7CA51846CF3DB69A014B9FEF005E327A5066643E121544135B8F393D347D2284FDC470C20FCC547CD43CE136E09D899B444209B8140976EBB9115F6D44118F9E6FB21597AD087E54471DAF85536238D68F43631785455D09F73C67736B288DF09F20153F2AA6D2B01E8EFEC85A5D2C4555FD1D72CAD4A7DA1E31D52DA9A285A834A5F95DBD11B928FF885224A69AA008D509417655521AB998FD10107A44A5662E6848E40E9A04915CF5372FDF7BAEBB0BEE3F736CABF32AD185C22FB3D6125A8E8048EE9E2243C9673A9128D1E58CBFC787F77A9DA7A833223D3E3CA2AFAC7A49E8A855A1F6502D40F2E7003C9C667C2D29332D346801C032F414DAB645D33F753C7C16BBA439AA44D8FA458E61DEC5E24E148ACD0CF86348FBEB7E5B167BF8F60B7EA474A9996DC7851B7E1FC3F93E4596B091E8B5C3E58C2729AB02C8D22A7DCC189C40CE0F5985704F0E68BB09EB7BA1F074264936A70EE83496F2AF434534BFC84B8B989D96AABD05A069D75A65

0x479144
D50415BD46879C1A97294115A0565D7A9C45EC846F4E14D490268FD5248D27CC50B50C595CC514E36F28CA06D24FA4AE1F409B538BC43E2E7172A85491C1B4B803D6292641EEB46B2A1E5F89B0EBED88AD1B8235F6A4B9EB4D34D9512726C42E61466B31E9A0CCA9649854A8C5394407A08EFC932FE6140B5C98F60E27C0ED4D8292A91C10BD6FC6A7200D01E3282C20581F124FA692C7A1E8B53530036011EA510C559AE48C02DC01488F678830183ECE539E3E69476D65321FD9F62B2611B200C4EE4AA7985753275F67C68350A477B28E0D5A7AA518462B3CB69A054B9FEF045E327AB867643E161544136C8A393DD87C2284EBC470C20CCC547CD63EE136E49D899B4C4209B8120B76EBBD115F6D64128F9E65B01597A1087E54471DAF85456038D68B4363178C455D09ED3E677369288DF09E20153F36A4D2B01A8EFEC85F5D2C4575FF1D72CED4A7DA2734D52D8DA085A814A5F95DE7865A689E707C52AF75C71AA01FE5BCA979C5F6F8B8DEF4266F979EF96F798966C2F10D7B80C1E6FA2E1D9100AFD0EA5226B1FC1D27715C3145FA8B1EC5064BE1244DD44240EE8D03CF07CB5B9C6D807BEA79A960CA39BD9813199B612D1EB6C829361AB7D48FDB0C716855185ACBC2755415D8973E193F3A6BD5E70B2B068AABD93ED8ABC9043B7D45F602FFD9A39978A08CF5E95AAF5FC85503993EE6284C160F34BC0781F69F9335E5007BE94C586D9985753E0068A719E350D928DDB0147D824F5E5ADF851086CD5F9A3F4FB8BAF6CB6A42E86A2E3AE3F7C6077D44B0C3F7D48F96723364FF11BA9A8E
```

XORing those together gets a table that has IDs, offsets and lengths that need to be further processed (same chunk
IDs XORed together to get plaintext)
